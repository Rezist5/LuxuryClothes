"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/products/[id]/page",{

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addToCart: function() { return /* binding */ addToCart; },\n/* harmony export */   confirmDelivery: function() { return /* binding */ confirmDelivery; },\n/* harmony export */   createCategory: function() { return /* binding */ createCategory; },\n/* harmony export */   createDiscount: function() { return /* binding */ createDiscount; },\n/* harmony export */   createOrder: function() { return /* binding */ createOrder; },\n/* harmony export */   createProduct: function() { return /* binding */ createProduct; },\n/* harmony export */   createReview: function() { return /* binding */ createReview; },\n/* harmony export */   deleteCategory: function() { return /* binding */ deleteCategory; },\n/* harmony export */   deleteDiscount: function() { return /* binding */ deleteDiscount; },\n/* harmony export */   deleteProduct: function() { return /* binding */ deleteProduct; },\n/* harmony export */   deleteReview: function() { return /* binding */ deleteReview; },\n/* harmony export */   fetchCart: function() { return /* binding */ fetchCart; },\n/* harmony export */   fetchCategories: function() { return /* binding */ fetchCategories; },\n/* harmony export */   fetchCategoryById: function() { return /* binding */ fetchCategoryById; },\n/* harmony export */   fetchCategoryProducts: function() { return /* binding */ fetchCategoryProducts; },\n/* harmony export */   fetchDiscounts: function() { return /* binding */ fetchDiscounts; },\n/* harmony export */   fetchFavorites: function() { return /* binding */ fetchFavorites; },\n/* harmony export */   fetchOrder: function() { return /* binding */ fetchOrder; },\n/* harmony export */   fetchOrders: function() { return /* binding */ fetchOrders; },\n/* harmony export */   fetchProduct: function() { return /* binding */ fetchProduct; },\n/* harmony export */   fetchProducts: function() { return /* binding */ fetchProducts; },\n/* harmony export */   fetchUser: function() { return /* binding */ fetchUser; },\n/* harmony export */   fetchUserPurchases: function() { return /* binding */ fetchUserPurchases; },\n/* harmony export */   fetchUserSales: function() { return /* binding */ fetchUserSales; },\n/* harmony export */   login: function() { return /* binding */ login; },\n/* harmony export */   logout: function() { return /* binding */ logout; },\n/* harmony export */   register: function() { return /* binding */ register; },\n/* harmony export */   removeFromCart: function() { return /* binding */ removeFromCart; },\n/* harmony export */   resetPassword: function() { return /* binding */ resetPassword; },\n/* harmony export */   searchProducts: function() { return /* binding */ searchProducts; },\n/* harmony export */   sendPasswordResetLink: function() { return /* binding */ sendPasswordResetLink; },\n/* harmony export */   toggleFavorite: function() { return /* binding */ toggleFavorite; },\n/* harmony export */   updateCartItem: function() { return /* binding */ updateCartItem; },\n/* harmony export */   updateCategory: function() { return /* binding */ updateCategory; },\n/* harmony export */   updateDiscount: function() { return /* binding */ updateDiscount; },\n/* harmony export */   updateProduct: function() { return /* binding */ updateProduct; },\n/* harmony export */   updateProfile: function() { return /* binding */ updateProfile; },\n/* harmony export */   updateReview: function() { return /* binding */ updateReview; },\n/* harmony export */   uploadPaymentProof: function() { return /* binding */ uploadPaymentProof; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n\n// В начале файла добавим проверку\nconst API_URL = \"http://localhost:8000/api\" || 0;\nconst BASE_URL = API_URL.replace(\"/api\", \"\");\n// Функция для получения CSRF токена\nasync function getCsrfToken() {\n    await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(BASE_URL, \"/sanctum/csrf-cookie\"), {\n        withCredentials: true\n    });\n}\n// Создаем экземпляр axios с базовыми настройками\nconst api = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: API_URL,\n    headers: {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\",\n        \"X-Requested-With\": \"XMLHttpRequest\"\n    },\n    withCredentials: true\n});\n// Добавляем интерцептор для получения CSRF-токена перед запросами\napi.interceptors.request.use(async (config)=>{\n    if (!document.cookie.includes(\"XSRF-TOKEN\") && config.method !== \"get\" && config.method !== \"head\") {\n        await getCsrfToken();\n    }\n    return config;\n});\n// Интерцептор для обработки ошибок\napi.interceptors.response.use((response)=>response, (error)=>{\n    var _error_response, _error_response1;\n    console.error(\"API Error:\", {\n        config: error.config,\n        response: (_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.data,\n        status: (_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.status\n    });\n    return Promise.reject(error);\n});\n// Экспортируем функции для работы с API\nconst login = async (email, password)=>{\n    try {\n        const { data } = await api.post(\"/auth/login\", {\n            email,\n            password\n        });\n        return data;\n    } catch (error) {\n        console.error(\"Login error details:\", error);\n        throw error;\n    }\n};\nconst register = async (data)=>{\n    const response = await api.post(\"/auth/register\", data);\n    return response.data;\n};\nconst logout = async ()=>{\n    try {\n        await api.post(\"/auth/logout\");\n        localStorage.removeItem(\"user\");\n        return true;\n    } catch (error) {\n        console.error(\"Logout error:\", error);\n        throw error;\n    }\n};\nconst fetchUser = async ()=>{\n    try {\n        const response = await api.get(\"/me\");\n        console.log(\"Fetched user data:\", response.data); // Для отладки\n        return response.data.user; // Убедимся, что возврщаем правильную структуру данных\n    } catch (error) {\n        console.error(\"Error fetching user:\", error);\n        throw error;\n    }\n};\n// Products\nconst fetchProducts = async (filters)=>{\n    try {\n        const params = new URLSearchParams();\n        if (filters) {\n            Object.entries(filters).forEach((param)=>{\n                let [key, value] = param;\n                if (value) {\n                    params.append(key, value);\n                }\n            });\n        }\n        const url = \"/products\".concat(params.toString() ? \"?\".concat(params.toString()) : \"\");\n        const { data } = await api.get(url);\n        return data;\n    } catch (error) {\n        console.error(\"Error fetching products:\", error);\n        throw error;\n    }\n};\nconst fetchProduct = async (id)=>{\n    try {\n        const { data } = await api.get(\"/products/\".concat(id));\n        return data;\n    } catch (error) {\n        console.error(\"Error fetching product:\", error);\n        throw error;\n    }\n};\nconst createProduct = async (productData)=>{\n    try {\n        // Сначала получаем CSRF токен\n        await getCsrfToken();\n        const { data } = await api.post(\"/products\", productData, {\n            headers: {\n                \"Content-Type\": \"multipart/form-data\"\n            }\n        });\n        return data;\n    } catch (error) {\n        console.error(\"Error creating product:\", error);\n        throw error;\n    }\n};\nconst updateProduct = async (id, productData)=>{\n    const { data } = await api.post(\"/products/\".concat(id), productData, {\n        headers: {\n            \"Content-Type\": \"multipart/form-data\"\n        }\n    });\n    return data;\n};\nconst deleteProduct = async (id)=>{\n    const { data } = await api.delete(\"/products/\".concat(id));\n    return data;\n};\n// Search\nconst searchProducts = async (query)=>{\n    try {\n        const { data } = await api.get(\"/search?q=\".concat(encodeURIComponent(query)));\n        return data;\n    } catch (error) {\n        console.error(\"Search error:\", error);\n        throw error;\n    }\n};\n// Categories\nconst fetchCategories = async ()=>{\n    try {\n        const { data } = await api.get(\"/categories\");\n        return data;\n    } catch (error) {\n        console.error(\"Error fetching categories:\", error);\n        throw error;\n    }\n};\nconst fetchCategoryProducts = async (slug, filters)=>{\n    try {\n        // Создаем объект с параметрами запроса\n        const params = new URLSearchParams();\n        // Добавляем только непустые значения фильтров\n        if (filters) {\n            Object.entries(filters).forEach((param)=>{\n                let [key, value] = param;\n                if (value) {\n                    params.append(key, value);\n                }\n            });\n        }\n        // Формируем URL с параметрами\n        const url = \"/categories/\".concat(slug, \"/products\").concat(params.toString() ? \"?\".concat(params.toString()) : \"\");\n        const { data } = await api.get(url);\n        return data;\n    } catch (error) {\n        console.error(\"Error fetching category products:\", error);\n        throw error;\n    }\n};\nconst fetchCategoryById = async (id)=>{\n    try {\n        const { data } = await api.get(\"/categories/\".concat(id));\n        return data;\n    } catch (error) {\n        console.error(\"Error fetching category:\", error);\n        throw error;\n    }\n};\n// Если нужно управление категориями в админке\nconst createCategory = async (categoryData)=>{\n    try {\n        const { data } = await api.post(\"/admin/categories\", categoryData, {\n            headers: {\n                \"Content-Type\": \"multipart/form-data\"\n            }\n        });\n        return data;\n    } catch (error) {\n        console.error(\"Error creating category:\", error);\n        throw error;\n    }\n};\nconst updateCategory = async (id, categoryData)=>{\n    try {\n        const { data } = await api.post(\"/admin/categories/\".concat(id), categoryData, {\n            headers: {\n                \"Content-Type\": \"multipart/form-data\"\n            }\n        });\n        return data;\n    } catch (error) {\n        console.error(\"Error updating category:\", error);\n        throw error;\n    }\n};\nconst deleteCategory = async (id)=>{\n    try {\n        const { data } = await api.delete(\"/admin/categories/\".concat(id));\n        return data;\n    } catch (error) {\n        console.error(\"Error deleting category:\", error);\n        throw error;\n    }\n};\n// Cart\nconst fetchCart = async ()=>{\n    const { data } = await api.get(\"/cart\");\n    return data;\n};\nconst addToCart = async function(productId) {\n    let quantity = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n    const { data } = await api.post(\"/cart/add\", {\n        product_id: productId,\n        quantity\n    });\n    return data;\n};\nconst updateCartItem = async (cartItemId, quantity)=>{\n    const { data } = await api.put(\"/cart/\".concat(cartItemId), {\n        quantity\n    });\n    return data;\n};\nconst removeFromCart = async (cartItemId)=>{\n    const { data } = await api.delete(\"/cart/\".concat(cartItemId));\n    return data;\n};\n// Orders\nconst fetchOrders = async ()=>{\n    const { data } = await api.get(\"/orders\");\n    return data;\n};\nconst createOrder = async (orderData)=>{\n    try {\n        // Добавим логирование для отладки\n        console.log(\"Creating order with data:\", orderData);\n        const { data } = await api.post(\"/orders\", orderData, {\n            headers: {\n                \"Content-Type\": \"application/json\"\n            }\n        });\n        console.log(\"Order created successfully:\", data);\n        return data;\n    } catch (error) {\n        var _error_response;\n        console.error(\"Create order error details:\", {\n            message: error.message,\n            response: (_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.data\n        });\n        throw error;\n    }\n};\n// Favorites\nconst fetchFavorites = async ()=>{\n    const { data } = await api.get(\"/favorites\");\n    return data;\n};\nconst toggleFavorite = async (productId)=>{\n    const { data } = await api.post(\"/products/\".concat(productId, \"/favorite\"));\n    return data;\n};\n// Reviews\nconst createReview = async (productId, reviewData)=>{\n    const { data } = await api.post(\"/products/\".concat(productId, \"/reviews\"), reviewData);\n    return data;\n};\nconst updateReview = async (reviewId, reviewData)=>{\n    const { data } = await api.put(\"/reviews/\".concat(reviewId), reviewData);\n    return data;\n};\nconst deleteReview = async (reviewId)=>{\n    const { data } = await api.delete(\"/reviews/\".concat(reviewId));\n    return data;\n};\n// Discounts\nconst fetchDiscounts = async ()=>{\n    const { data } = await api.get(\"/admin/discounts\");\n    return data;\n};\nconst createDiscount = async (discountData)=>{\n    const { data } = await api.post(\"/admin/discounts\", discountData);\n    return data;\n};\nconst updateDiscount = async (id, discountData)=>{\n    const { data } = await api.put(\"/admin/discounts/\".concat(id), discountData);\n    return data;\n};\nconst deleteDiscount = async (id)=>{\n    const { data } = await api.delete(\"/admin/discounts/\".concat(id));\n    return data;\n};\n// Добавим новые методы\nconst fetchUserSales = async ()=>{\n    const { data } = await api.get(\"/user/sales\");\n    return data;\n};\nconst fetchUserPurchases = async ()=>{\n    const { data } = await api.get(\"/user/purchases\");\n    return data;\n};\nconst updateProfile = async (data)=>{\n    try {\n        // Преобразуем FormData в объект для отправки\n        const formDataObj = {};\n        data.forEach((value, key)=>{\n            // Пропускаем пустые знаения\n            if (value !== \"\" && value !== null && value !== undefined) {\n                formDataObj[key] = value;\n            }\n        });\n        console.log(\"Sending data:\", formDataObj); // Для отладки\n        const response = await api.put(\"/profile\", formDataObj);\n        // Для отладки\n        console.log(\"Server response:\", response.data);\n        // Обновляем кэш пользователя\n        await api.get(\"/me\");\n        return response.data;\n    } catch (error) {\n        console.error(\"Profile update error:\", error);\n        throw error;\n    }\n};\nconst sendPasswordResetLink = async (email)=>{\n    try {\n        var _document_querySelector;\n        const response = await api.post(\"/forgot-password\", {\n            email,\n            _token: (_document_querySelector = document.querySelector('meta[name=\"csrf-token\"]')) === null || _document_querySelector === void 0 ? void 0 : _document_querySelector.getAttribute(\"content\")\n        });\n        return response.data;\n    } catch (error) {\n        console.error(\"Password reset error:\", error);\n        throw error;\n    }\n};\nconst resetPassword = async (data)=>{\n    try {\n        const response = await api.post(\"/reset-password\", data);\n        return response.data;\n    } catch (error) {\n        var _error_response;\n        console.error(\"Password reset error:\", (_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.data);\n        throw error;\n    }\n};\nconst uploadPaymentProof = async (orderId, data)=>{\n    const response = await api.post(\"/orders/\".concat(orderId, \"/payment\"), data, {\n        headers: {\n            \"Content-Type\": \"multipart/form-data\"\n        }\n    });\n    return response.data;\n};\nconst confirmDelivery = async (orderId)=>{\n    const response = await api.post(\"/orders/\".concat(orderId, \"/delivery\"));\n    return response.data;\n};\nconst fetchOrder = async (orderId)=>{\n    const response = await api.get(\"/orders/\".concat(orderId));\n    return response.data;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYXBpLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEI7QUFFMUIsa0NBQWtDO0FBQ2xDLE1BQU1DLFVBQVVDLDJCQUErQixJQUFJO0FBQ25ELE1BQU1HLFdBQVdKLFFBQVFLLE9BQU8sQ0FBQyxRQUFRO0FBRXpDLG9DQUFvQztBQUNwQyxlQUFlQztJQUNiLE1BQU1QLDZDQUFLQSxDQUFDUSxHQUFHLENBQUMsR0FBWSxPQUFUSCxVQUFTLHlCQUF1QjtRQUNqREksaUJBQWlCO0lBQ25CO0FBQ0Y7QUFFQSxpREFBaUQ7QUFDakQsTUFBTUMsTUFBTVYsNkNBQUtBLENBQUNXLE1BQU0sQ0FBQztJQUN2QkMsU0FBU1g7SUFDVFksU0FBUztRQUNQLGdCQUFnQjtRQUNoQixVQUFVO1FBQ1Ysb0JBQW9CO0lBQ3RCO0lBQ0FKLGlCQUFpQjtBQUNuQjtBQUVBLGtFQUFrRTtBQUNsRUMsSUFBSUksWUFBWSxDQUFDQyxPQUFPLENBQUNDLEdBQUcsQ0FBQyxPQUFPQztJQUNsQyxJQUNFLENBQUNDLFNBQVNDLE1BQU0sQ0FBQ0MsUUFBUSxDQUFDLGlCQUMxQkgsT0FBT0ksTUFBTSxLQUFLLFNBQ2xCSixPQUFPSSxNQUFNLEtBQUssUUFDbEI7UUFDQSxNQUFNZDtJQUNSO0lBQ0EsT0FBT1U7QUFDVDtBQUVBLG1DQUFtQztBQUNuQ1AsSUFBSUksWUFBWSxDQUFDUSxRQUFRLENBQUNOLEdBQUcsQ0FDM0JNLENBQUFBLFdBQVlBLFVBQ1pDLENBQUFBO1FBR2NBLGlCQUNGQTtJQUhWQyxRQUFRRCxLQUFLLENBQUMsY0FBYztRQUMxQk4sUUFBUU0sTUFBTU4sTUFBTTtRQUNwQkssUUFBUSxHQUFFQyxrQkFBQUEsTUFBTUQsUUFBUSxjQUFkQyxzQ0FBQUEsZ0JBQWdCRSxJQUFJO1FBQzlCQyxNQUFNLEdBQUVILG1CQUFBQSxNQUFNRCxRQUFRLGNBQWRDLHVDQUFBQSxpQkFB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STtBQUN0QixFQUFFO0FBRUssTUFBTWtGLGtCQUFrQixPQUFPRDtJQUNwQyxNQUFNcEYsV0FBVyxNQUFNWixJQUFJc0IsSUFBSSxDQUFDLFdBQW1CLE9BQVIwRSxTQUFRO0lBQ25ELE9BQU9wRixTQUFTRyxJQUFJO0FBQ3RCLEVBQUU7QUFFSyxNQUFNbUYsYUFBYSxPQUFPRjtJQUMvQixNQUFNcEYsV0FBVyxNQUFNWixJQUFJRixHQUFHLENBQUMsV0FBbUIsT0FBUmtHO0lBQzFDLE9BQU9wRixTQUFTRyxJQUFJO0FBQ3RCLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9hcGkudHM/MmZhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuXG4vLyDQkiDQvdCw0YfQsNC70LUg0YTQsNC50LvQsCDQtNC+0LHQsNCy0LjQvCDQv9GA0L7QstC10YDQutGDXG5jb25zdCBBUElfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDo4MDAwL2FwaSc7XG5jb25zdCBCQVNFX1VSTCA9IEFQSV9VUkwucmVwbGFjZSgnL2FwaScsICcnKTtcblxuLy8g0KTRg9C90LrRhtC40Y8g0LTQu9GPINC/0L7Qu9GD0YfQtdC90LjRjyBDU1JGINGC0L7QutC10L3QsFxuYXN5bmMgZnVuY3Rpb24gZ2V0Q3NyZlRva2VuKCkge1xuICBhd2FpdCBheGlvcy5nZXQoYCR7QkFTRV9VUkx9L3NhbmN0dW0vY3NyZi1jb29raWVgLCB7XG4gICAgd2l0aENyZWRlbnRpYWxzOiB0cnVlXG4gIH0pO1xufVxuXG4vLyDQodC+0LfQtNCw0LXQvCDRjdC60LfQtdC80L/Qu9GP0YAgYXhpb3Mg0YEg0LHQsNC30L7QstGL0LzQuCDQvdCw0YHRgtGA0L7QudC60LDQvNC4XG5jb25zdCBhcGkgPSBheGlvcy5jcmVhdGUoe1xuICBiYXNlVVJMOiBBUElfVVJMLFxuICBoZWFkZXJzOiB7XG4gICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICdYLVJlcXVlc3RlZC1XaXRoJzogJ1hNTEh0dHBSZXF1ZXN0J1xuICB9LFxuICB3aXRoQ3JlZGVudGlhbHM6IHRydWVcbn0pO1xuXG4vLyDQlNC+0LHQsNCy0LvRj9C10Lwg0LjQvdGC0LXRgNGG0LXQv9GC0L7RgCDQtNC70Y8g0L/QvtC70YPRh9C10L3QuNGPIENTUkYt0YLQvtC60LXQvdCwINC/0LXRgNC10LQg0LfQsNC/0YDQvtGB0LDQvNC4XG5hcGkuaW50ZXJjZXB0b3JzLnJlcXVlc3QudXNlKGFzeW5jIChjb25maWcpID0+IHtcbiAgaWYgKFxuICAgICFkb2N1bWVudC5jb29raWUuaW5jbHVkZXMoJ1hTUkYtVE9LRU4nKSAmJiBcbiAgICBjb25maWcubWV0aG9kICE9PSAnZ2V0JyAmJiBcbiAgICBjb25maWcubWV0aG9kICE9PSAnaGVhZCdcbiAgKSB7XG4gICAgYXdhaXQgZ2V0Q3NyZlRva2VuKCk7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZztcbn0pO1xuXG4vLyDQmNC90YLQtdGA0YbQtdC/0YLQvtGAINC00LvRjyDQvtCx0YDQsNCx0L7RgtC60Lgg0L7RiNC40LHQvtC6XG5hcGkuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLnVzZShcbiAgcmVzcG9uc2UgPT4gcmVzcG9uc2UsXG4gIGVycm9yID0+IHtcbiAgICBjb25zb2xlLmVycm9yKCdBUEkgRXJyb3I6Jywge1xuICAgICAgY29uZmlnOiBlcnJvci5jb25maWcsXG4gICAgICByZXNwb25zZTogZXJyb3IucmVzcG9uc2U/LmRhdGEsXG4gICAgICBzdGF0dXM6IGVycm9yLnJlc3BvbnNlPy5zdGF0dXNcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICB9XG4pO1xuXG4vLyDQrdC60YHQv9C+0YDRgtC40YDRg9C10Lwg0YTRg9C90LrRhtC40Lgg0LTQu9GPINGA0LDQsdC+0YLRiyDRgSBBUElcbmV4cG9ydCBjb25zdCBsb2dpbiA9IGFzeW5jIChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBhcGkucG9zdCgnL2F1dGgvbG9naW4nLCB7XG4gICAgICBlbWFpbCxcbiAgICAgIHBhc3N3b3JkXG4gICAgfSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignTG9naW4gZXJyb3IgZGV0YWlsczonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyID0gYXN5bmMgKGRhdGE6IHtcbiAgbmFtZTogc3RyaW5nO1xuICBlbWFpbDogc3RyaW5nO1xuICBwYXNzd29yZDogc3RyaW5nO1xuICBwYXNzd29yZF9jb25maXJtYXRpb246IHN0cmluZztcbn0pID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdCgnL2F1dGgvcmVnaXN0ZXInLCBkYXRhKTtcbiAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG59XG5cbmV4cG9ydCBjb25zdCBsb2dvdXQgPSBhc3luYyAoKSA9PiB7XG4gIHRyeSB7XG4gICAgYXdhaXQgYXBpLnBvc3QoJy9hdXRoL2xvZ291dCcpO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCd1c2VyJyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignTG9nb3V0IGVycm9yOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGZldGNoVXNlciA9IGFzeW5jICgpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQoJy9tZScpO1xuICAgIGNvbnNvbGUubG9nKCdGZXRjaGVkIHVzZXIgZGF0YTonLCByZXNwb25zZS5kYXRhKTsgLy8g0JTQu9GPINC+0YLQu9Cw0LTQutC4XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEudXNlcjsgLy8g0KPQsdC10LTQuNC80YHRjywg0YfRgtC+INCy0L7Qt9Cy0YDRidCw0LXQvCDQv9GA0LDQstC40LvRjNC90YPRjiDRgdGC0YDRg9C60YLRg9GA0YMg0LTQsNC90L3Ri9GFXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgdXNlcjonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8vIFByb2R1Y3RzXG5leHBvcnQgY29uc3QgZmV0Y2hQcm9kdWN0cyA9IGFzeW5jIChmaWx0ZXJzPzoge1xuICBnZW5kZXI/OiBzdHJpbmc7XG4gIGNvbmRpdGlvbj86IHN0cmluZztcbiAgc2l6ZT86IHN0cmluZztcbiAgbWluUHJpY2U/OiBzdHJpbmc7XG4gIG1heFByaWNlPzogc3RyaW5nO1xuICBzb3J0Pzogc3RyaW5nO1xuICBsaW1pdD86IHN0cmluZztcbn0pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgXG4gICAgaWYgKGZpbHRlcnMpIHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKGZpbHRlcnMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBwYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB1cmwgPSBgL3Byb2R1Y3RzJHtwYXJhbXMudG9TdHJpbmcoKSA/IGA/JHtwYXJhbXMudG9TdHJpbmcoKX1gIDogJyd9YDtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwaS5nZXQodXJsKTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwcm9kdWN0czonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBmZXRjaFByb2R1Y3QgPSBhc3luYyAoaWQ6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYXBpLmdldChgL3Byb2R1Y3RzLyR7aWR9YCk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHJvZHVjdDonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQcm9kdWN0ID0gYXN5bmMgKHByb2R1Y3REYXRhOiBGb3JtRGF0YSkgPT4ge1xuICB0cnkge1xuICAgIC8vINCh0L3QsNGH0LDQu9CwINC/0L7Qu9GD0YfQsNC10LwgQ1NSRiDRgtC+0LrQtdC9XG4gICAgYXdhaXQgZ2V0Q3NyZlRva2VuKCk7XG4gICAgXG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBhcGkucG9zdCgnL3Byb2R1Y3RzJywgcHJvZHVjdERhdGEsIHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJyxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgcHJvZHVjdDonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVQcm9kdWN0ID0gYXN5bmMgKGlkOiBzdHJpbmcsIHByb2R1Y3REYXRhOiBGb3JtRGF0YSkgPT4ge1xuICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwaS5wb3N0KGAvcHJvZHVjdHMvJHtpZH1gLCBwcm9kdWN0RGF0YSwge1xuICAgIGhlYWRlcnM6IHtcbiAgICAgICdDb250ZW50LVR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScsXG4gICAgfSxcbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufTtcblxuZXhwb3J0IGNvbnN0IGRlbGV0ZVByb2R1Y3QgPSBhc3luYyAoaWQ6IHN0cmluZykgPT4ge1xuICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwaS5kZWxldGUoYC9wcm9kdWN0cy8ke2lkfWApO1xuICByZXR1cm4gZGF0YTtcbn07XG5cbi8vIFNlYXJjaFxuZXhwb3J0IGNvbnN0IHNlYXJjaFByb2R1Y3RzID0gYXN5bmMgKHF1ZXJ5OiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwaS5nZXQoYC9zZWFyY2g/cT0ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeSl9YCk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignU2VhcmNoIGVycm9yOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuLy8gQ2F0ZWdvcmllc1xuZXhwb3J0IGNvbnN0IGZldGNoQ2F0ZWdvcmllcyA9IGFzeW5jICgpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwaS5nZXQoJy9jYXRlZ29yaWVzJyk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY2F0ZWdvcmllczonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBmZXRjaENhdGVnb3J5UHJvZHVjdHMgPSBhc3luYyAoXG4gIHNsdWc6IHN0cmluZyxcbiAgZmlsdGVycz86IHtcbiAgICBnZW5kZXI/OiBzdHJpbmc7XG4gICAgY29uZGl0aW9uPzogc3RyaW5nO1xuICAgIHNpemU/OiBzdHJpbmc7XG4gICAgbWluUHJpY2U/OiBzdHJpbmc7XG4gICAgbWF4UHJpY2U/OiBzdHJpbmc7XG4gICAgc29ydD86IHN0cmluZztcbiAgfVxuKSA9PiB7XG4gIHRyeSB7XG4gICAgLy8g0KHQvtC30LTQsNC10Lwg0L7QsdGK0LXQutGCINGBINC/0LDRgNCw0LzQtdGC0YDQsNC80Lgg0LfQsNC/0YDQvtGB0LBcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgXG4gICAgLy8g0JTQvtCx0LDQstC70Y/QtdC8INGC0L7Qu9GM0LrQviDQvdC10L/Rg9GB0YLRi9C1INC30L3QsNGH0LXQvdC40Y8g0YTQuNC70YzRgtGA0L7QslxuICAgIGlmIChmaWx0ZXJzKSB7XG4gICAgICBPYmplY3QuZW50cmllcyhmaWx0ZXJzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgcGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8g0KTQvtGA0LzQuNGA0YPQtdC8IFVSTCDRgSDQv9Cw0YDQsNC80LXRgtGA0LDQvNC4XG4gICAgY29uc3QgdXJsID0gYC9jYXRlZ29yaWVzLyR7c2x1Z30vcHJvZHVjdHMke3BhcmFtcy50b1N0cmluZygpID8gYD8ke3BhcmFtcy50b1N0cmluZygpfWAgOiAnJ31gO1xuICAgIFxuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYXBpLmdldCh1cmwpO1xuICAgIHJldHVybiBkYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGNhdGVnb3J5IHByb2R1Y3RzOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGZldGNoQ2F0ZWdvcnlCeUlkID0gYXN5bmMgKGlkOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwaS5nZXQoYC9jYXRlZ29yaWVzLyR7aWR9YCk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY2F0ZWdvcnk6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG4vLyDQldGB0LvQuCDQvdGD0LbQvdC+INGD0L/RgNCw0LLQu9C10L3QuNC1INC60LDRgtC10LPQvtGA0LjRj9C80Lgg0LIg0LDQtNC80LjQvdC60LVcbmV4cG9ydCBjb25zdCBjcmVhdGVDYXRlZ29yeSA9IGFzeW5jIChjYXRlZ29yeURhdGE6IEZvcm1EYXRhKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBhcGkucG9zdCgnL2FkbWluL2NhdGVnb3JpZXMnLCBjYXRlZ29yeURhdGEsIHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJyxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgY2F0ZWdvcnk6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgdXBkYXRlQ2F0ZWdvcnkgPSBhc3luYyAoaWQ6IHN0cmluZywgY2F0ZWdvcnlEYXRhOiBGb3JtRGF0YSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYXBpLnBvc3QoYC9hZG1pbi9jYXRlZ29yaWVzLyR7aWR9YCwgY2F0ZWdvcnlEYXRhLCB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScsXG4gICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBkYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGNhdGVnb3J5OicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGRlbGV0ZUNhdGVnb3J5ID0gYXN5bmMgKGlkOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwaS5kZWxldGUoYC9hZG1pbi9jYXRlZ29yaWVzLyR7aWR9YCk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgY2F0ZWdvcnk6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG4vLyBDYXJ0XG5leHBvcnQgY29uc3QgZmV0Y2hDYXJ0ID0gYXN5bmMgKCkgPT4ge1xuICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwaS5nZXQoJy9jYXJ0JylcbiAgcmV0dXJuIGRhdGFcbn1cblxuZXhwb3J0IGNvbnN0IGFkZFRvQ2FydCA9IGFzeW5jIChwcm9kdWN0SWQ6IHN0cmluZywgcXVhbnRpdHk6IG51bWJlciA9IDEpID0+IHtcbiAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBhcGkucG9zdCgnL2NhcnQvYWRkJywgeyBcbiAgICBwcm9kdWN0X2lkOiBwcm9kdWN0SWQsIFxuICAgIHF1YW50aXR5IFxuICB9KVxuICByZXR1cm4gZGF0YVxufVxuXG5leHBvcnQgY29uc3QgdXBkYXRlQ2FydEl0ZW0gPSBhc3luYyAoY2FydEl0ZW1JZDogbnVtYmVyLCBxdWFudGl0eTogbnVtYmVyKSA9PiB7XG4gIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYXBpLnB1dChgL2NhcnQvJHtjYXJ0SXRlbUlkfWAsIHsgcXVhbnRpdHkgfSlcbiAgcmV0dXJuIGRhdGFcbn1cblxuZXhwb3J0IGNvbnN0IHJlbW92ZUZyb21DYXJ0ID0gYXN5bmMgKGNhcnRJdGVtSWQ6IG51bWJlcikgPT4ge1xuICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwaS5kZWxldGUoYC9jYXJ0LyR7Y2FydEl0ZW1JZH1gKVxuICByZXR1cm4gZGF0YVxufVxuXG4vLyBPcmRlcnNcbmV4cG9ydCBjb25zdCBmZXRjaE9yZGVycyA9IGFzeW5jICgpID0+IHtcbiAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBhcGkuZ2V0KCcvb3JkZXJzJyk7XG4gIHJldHVybiBkYXRhO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZU9yZGVyID0gYXN5bmMgKG9yZGVyRGF0YToge1xuICBkZWxpdmVyeV9hZGRyZXNzOiBzdHJpbmdcbn0pID0+IHtcbiAgdHJ5IHtcbiAgICAvLyDQlNC+0LHQsNCy0LjQvCDQu9C+0LPQuNGA0L7QstCw0L3QuNC1INC00LvRjyDQvtGC0LvQsNC00LrQuFxuICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyBvcmRlciB3aXRoIGRhdGE6Jywgb3JkZXJEYXRhKTtcbiAgICBcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwaS5wb3N0KCcvb3JkZXJzJywgb3JkZXJEYXRhLCB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygnT3JkZXIgY3JlYXRlZCBzdWNjZXNzZnVsbHk6JywgZGF0YSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdDcmVhdGUgb3JkZXIgZXJyb3IgZGV0YWlsczonLCB7XG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgcmVzcG9uc2U6IGVycm9yLnJlc3BvbnNlPy5kYXRhXG4gICAgfSk7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8vIEZhdm9yaXRlc1xuZXhwb3J0IGNvbnN0IGZldGNoRmF2b3JpdGVzID0gYXN5bmMgKCkgPT4ge1xuICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwaS5nZXQoJy9mYXZvcml0ZXMnKTtcbiAgcmV0dXJuIGRhdGE7XG59O1xuXG5leHBvcnQgY29uc3QgdG9nZ2xlRmF2b3JpdGUgPSBhc3luYyAocHJvZHVjdElkOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBhcGkucG9zdChgL3Byb2R1Y3RzLyR7cHJvZHVjdElkfS9mYXZvcml0ZWApO1xuICByZXR1cm4gZGF0YTtcbn07XG5cbi8vIFJldmlld3NcbmV4cG9ydCBjb25zdCBjcmVhdGVSZXZpZXcgPSBhc3luYyAocHJvZHVjdElkOiBzdHJpbmcsIHJldmlld0RhdGE6IGFueSkgPT4ge1xuICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwaS5wb3N0KGAvcHJvZHVjdHMvJHtwcm9kdWN0SWR9L3Jldmlld3NgLCByZXZpZXdEYXRhKTtcbiAgcmV0dXJuIGRhdGE7XG59O1xuXG5leHBvcnQgY29uc3QgdXBkYXRlUmV2aWV3ID0gYXN5bmMgKHJldmlld0lkOiBzdHJpbmcsIHJldmlld0RhdGE6IGFueSkgPT4ge1xuICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwaS5wdXQoYC9yZXZpZXdzLyR7cmV2aWV3SWR9YCwgcmV2aWV3RGF0YSk7XG4gIHJldHVybiBkYXRhO1xufTtcblxuZXhwb3J0IGNvbnN0IGRlbGV0ZVJldmlldyA9IGFzeW5jIChyZXZpZXdJZDogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYXBpLmRlbGV0ZShgL3Jldmlld3MvJHtyZXZpZXdJZH1gKTtcbiAgcmV0dXJuIGRhdGE7XG59O1xuXG4vLyBEaXNjb3VudHNcbmV4cG9ydCBjb25zdCBmZXRjaERpc2NvdW50cyA9IGFzeW5jICgpID0+IHtcbiAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBhcGkuZ2V0KCcvYWRtaW4vZGlzY291bnRzJyk7XG4gIHJldHVybiBkYXRhO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZURpc2NvdW50ID0gYXN5bmMgKGRpc2NvdW50RGF0YTogYW55KSA9PiB7XG4gIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYXBpLnBvc3QoJy9hZG1pbi9kaXNjb3VudHMnLCBkaXNjb3VudERhdGEpO1xuICByZXR1cm4gZGF0YTtcbn07XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVEaXNjb3VudCA9IGFzeW5jIChpZDogc3RyaW5nLCBkaXNjb3VudERhdGE6IGFueSkgPT4ge1xuICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwaS5wdXQoYC9hZG1pbi9kaXNjb3VudHMvJHtpZH1gLCBkaXNjb3VudERhdGEpO1xuICByZXR1cm4gZGF0YTtcbn07XG5cbmV4cG9ydCBjb25zdCBkZWxldGVEaXNjb3VudCA9IGFzeW5jIChpZDogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYXBpLmRlbGV0ZShgL2FkbWluL2Rpc2NvdW50cy8ke2lkfWApO1xuICByZXR1cm4gZGF0YTtcbn07XG5cbi8vINCU0L7QsdCw0LLQuNC8INC90L7QstGL0LUg0LzQtdGC0L7QtNGLXG5leHBvcnQgY29uc3QgZmV0Y2hVc2VyU2FsZXMgPSBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYXBpLmdldCgnL3VzZXIvc2FsZXMnKTtcbiAgcmV0dXJuIGRhdGE7XG59O1xuXG5leHBvcnQgY29uc3QgZmV0Y2hVc2VyUHVyY2hhc2VzID0gYXN5bmMgKCkgPT4ge1xuICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwaS5nZXQoJy91c2VyL3B1cmNoYXNlcycpO1xuICByZXR1cm4gZGF0YTtcbn07XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVQcm9maWxlID0gYXN5bmMgKGRhdGE6IEZvcm1EYXRhKSA9PiB7XG4gIHRyeSB7XG4gICAgLy8g0J/RgNC10L7QsdGA0LDQt9GD0LXQvCBGb3JtRGF0YSDQsiDQvtCx0YrQtdC60YIg0LTQu9GPINC+0YLQv9GA0LDQstC60LhcbiAgICBjb25zdCBmb3JtRGF0YU9iajogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9O1xuICAgIGRhdGEuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgLy8g0J/RgNC+0L/Rg9GB0LrQsNC10Lwg0L/Rg9GB0YLRi9C1INC30L3QsNC10L3QuNGPXG4gICAgICBpZiAodmFsdWUgIT09ICcnICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9ybURhdGFPYmpba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc29sZS5sb2coJ1NlbmRpbmcgZGF0YTonLCBmb3JtRGF0YU9iaik7IC8vINCU0LvRjyDQvtGC0LvQsNC00LrQuFxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucHV0KCcvcHJvZmlsZScsIGZvcm1EYXRhT2JqKTtcblxuICAgIC8vINCU0LvRjyDQvtGC0LvQsNC00LrQuFxuICAgIGNvbnNvbGUubG9nKCdTZXJ2ZXIgcmVzcG9uc2U6JywgcmVzcG9uc2UuZGF0YSk7XG5cbiAgICAvLyDQntCx0L3QvtCy0LvRj9C10Lwg0LrRjdGIINC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRj1xuICAgIGF3YWl0IGFwaS5nZXQoJy9tZScpO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignUHJvZmlsZSB1cGRhdGUgZXJyb3I6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3Qgc2VuZFBhc3N3b3JkUmVzZXRMaW5rID0gYXN5bmMgKGVtYWlsOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0KCcvZm9yZ290LXBhc3N3b3JkJywgeyBcbiAgICAgIGVtYWlsLFxuICAgICAgX3Rva2VuOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9XCJjc3JmLXRva2VuXCJdJyk/LmdldEF0dHJpYnV0ZSgnY29udGVudCcpXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignUGFzc3dvcmQgcmVzZXQgZXJyb3I6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcmVzZXRQYXNzd29yZCA9IGFzeW5jIChkYXRhOiB7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIHBhc3N3b3JkOiBzdHJpbmc7XG4gIHBhc3N3b3JkX2NvbmZpcm1hdGlvbjogc3RyaW5nO1xufSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy9yZXNldC1wYXNzd29yZCcsIGRhdGEpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignUGFzc3dvcmQgcmVzZXQgZXJyb3I6JywgZXJyb3IucmVzcG9uc2U/LmRhdGEpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgdXBsb2FkUGF5bWVudFByb29mID0gYXN5bmMgKG9yZGVySWQ6IG51bWJlciwgZGF0YTogRm9ybURhdGEpID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdChgL29yZGVycy8ke29yZGVySWR9L3BheW1lbnRgLCBkYXRhLCB7XG4gICAgaGVhZGVyczoge1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJyxcbiAgICB9LFxuICB9KTtcbiAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG59O1xuXG5leHBvcnQgY29uc3QgY29uZmlybURlbGl2ZXJ5ID0gYXN5bmMgKG9yZGVySWQ6IG51bWJlcikgPT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0KGAvb3JkZXJzLyR7b3JkZXJJZH0vZGVsaXZlcnlgKTtcbiAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG59O1xuXG5leHBvcnQgY29uc3QgZmV0Y2hPcmRlciA9IGFzeW5jIChvcmRlcklkOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KGAvb3JkZXJzLyR7b3JkZXJJZH1gKTtcbiAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG59OyJdLCJuYW1lcyI6WyJheGlvcyIsIkFQSV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsIkJBU0VfVVJMIiwicmVwbGFjZSIsImdldENzcmZUb2tlbiIsImdldCIsIndpdGhDcmVkZW50aWFscyIsImFwaSIsImNyZWF0ZSIsImJhc2VVUkwiLCJoZWFkZXJzIiwiaW50ZXJjZXB0b3JzIiwicmVxdWVzdCIsInVzZSIsImNvbmZpZyIsImRvY3VtZW50IiwiY29va2llIiwiaW5jbHVkZXMiLCJtZXRob2QiLCJyZXNwb25zZSIsImVycm9yIiwiY29uc29sZSIsImRhdGEiLCJzdGF0dXMiLCJQcm9taXNlIiwicmVqZWN0IiwibG9naW4iLCJlbWFpbCIsInBhc3N3b3JkIiwicG9zdCIsInJlZ2lzdGVyIiwibG9nb3V0IiwibG9jYWxTdG9yYWdlIiwicmVtb3ZlSXRlbSIsImZldGNoVXNlciIsImxvZyIsInVzZXIiLCJmZXRjaFByb2R1Y3RzIiwiZmlsdGVycyIsInBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsIk9iamVjdCIsImVudHJpZXMiLCJmb3JFYWNoIiwia2V5IiwidmFsdWUiLCJhcHBlbmQiLCJ1cmwiLCJ0b1N0cmluZyIsImZldGNoUHJvZHVjdCIsImlkIiwiY3JlYXRlUHJvZHVjdCIsInByb2R1Y3REYXRhIiwidXBkYXRlUHJvZHVjdCIsImRlbGV0ZVByb2R1Y3QiLCJkZWxldGUiLCJzZWFyY2hQcm9kdWN0cyIsInF1ZXJ5IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZmV0Y2hDYXRlZ29yaWVzIiwiZmV0Y2hDYXRlZ29yeVByb2R1Y3RzIiwic2x1ZyIsImZldGNoQ2F0ZWdvcnlCeUlkIiwiY3JlYXRlQ2F0ZWdvcnkiLCJjYXRlZ29yeURhdGEiLCJ1cGRhdGVDYXRlZ29yeSIsImRlbGV0ZUNhdGVnb3J5IiwiZmV0Y2hDYXJ0IiwiYWRkVG9DYXJ0IiwicHJvZHVjdElkIiwicXVhbnRpdHkiLCJwcm9kdWN0X2lkIiwidXBkYXRlQ2FydEl0ZW0iLCJjYXJ0SXRlbUlkIiwicHV0IiwicmVtb3ZlRnJvbUNhcnQiLCJmZXRjaE9yZGVycyIsImNyZWF0ZU9yZGVyIiwib3JkZXJEYXRhIiwibWVzc2FnZSIsImZldGNoRmF2b3JpdGVzIiwidG9nZ2xlRmF2b3JpdGUiLCJjcmVhdGVSZXZpZXciLCJyZXZpZXdEYXRhIiwidXBkYXRlUmV2aWV3IiwicmV2aWV3SWQiLCJkZWxldGVSZXZpZXciLCJmZXRjaERpc2NvdW50cyIsImNyZWF0ZURpc2NvdW50IiwiZGlzY291bnREYXRhIiwidXBkYXRlRGlzY291bnQiLCJkZWxldGVEaXNjb3VudCIsImZldGNoVXNlclNhbGVzIiwiZmV0Y2hVc2VyUHVyY2hhc2VzIiwidXBkYXRlUHJvZmlsZSIsImZvcm1EYXRhT2JqIiwidW5kZWZpbmVkIiwic2VuZFBhc3N3b3JkUmVzZXRMaW5rIiwiX3Rva2VuIiwicXVlcnlTZWxlY3RvciIsImdldEF0dHJpYnV0ZSIsInJlc2V0UGFzc3dvcmQiLCJ1cGxvYWRQYXltZW50UHJvb2YiLCJvcmRlcklkIiwiY29uZmlybURlbGl2ZXJ5IiwiZmV0Y2hPcmRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ })

});